import os
import json
import datetime
import importlib
import asyncio
from typing import List

from fastmcp import FastMCP
from motor.motor_asyncio import AsyncIOMotorClient

# Local imports
import reviewer_values
# We import the tool function directly. Note that it's an async function decorated with @tool.
# FastMCP can wrap it, or we can call it directly. 
# Since we need to match the signature requested by the user, we will wrap it.
from reviewer_rag_tool import reviewer_retriever_tool

# Initialize FastMCP
mcp = FastMCP("Reviewer_MCP")

# Environment Variables
REVIEWER_MONGODB_URI = os.getenv("REVIEWER_MONGODB_URI")
REVIEWER_MONGODB_DATABASE = os.getenv("REVIEWER_MONGODB_DATABASE")
REVIEWER_MONGODB_COLLECTION = os.getenv("REVIEWER_MONGODB_COLLECTION") # Questions collection

# --- Helper Functions for Reviewer Data Update ---

async def update_reviewer_data():
    """
    Checks if reviewer_values.py needs an update (older than 24h).
    If so, fetches new data from MongoDB, rewrites reviewer_values.py, and reloads the module.
    """
    print("Checking for Reviewer Data updates...")
    
    # Check last update time
    last_updated_str = getattr(reviewer_values, "last_updated_metadata", "2000-01-01T00:00:00")
    try:
        last_updated = datetime.datetime.fromisoformat(last_updated_str)
    except ValueError:
        last_updated = datetime.datetime(2000, 1, 1)

    # Use IST for consistency
    ist_timezone = datetime.timezone(datetime.timedelta(hours=5, minutes=30))
    today_ist = datetime.datetime.now(ist_timezone)
    
    if last_updated.tzinfo is None:
         last_updated = last_updated.replace(tzinfo=ist_timezone)

    if (today_ist - last_updated) < datetime.timedelta(hours=6):
        print("Reviewer Data is up-to-date. Skipping update.")
        return

    print("Reviewer Data is stale. Fetching from MongoDB...")

    try:
        if not REVIEWER_MONGODB_URI or not REVIEWER_MONGODB_DATABASE:
            print("Error: Missing MongoDB credentials in env.")
            return

        mongo_client = AsyncIOMotorClient(REVIEWER_MONGODB_URI, serverSelectionTimeoutMS=5000)
        database = mongo_client[REVIEWER_MONGODB_DATABASE]
        questions_collection = database[REVIEWER_MONGODB_COLLECTION]

        # 1. Fetch State Crops Mapping
        pipeline = [
            {
                "$match": {
                    "details.state": {"$exists": True, "$ne": None},
                    "details.crop": {"$exists": True, "$ne": None},
                }
            },
            {
                "$group": {
                    "_id": "$details.state",
                    "crops": {"$addToSet": "$details.crop"}
                }
            },
            {"$sort": {"_id": 1}}
        ]
        
        cursor = questions_collection.aggregate(pipeline)
        state_crops_reviewer_dataset = {}
        async for doc in cursor:
            state_key = doc["_id"]
            state_crops_reviewer_dataset[state_key] = sorted(list(doc["crops"]))
        
        # 2. Get distinct states for the codes mapping
        distinct_states = await questions_collection.distinct("details.state", {"details.state": {"$exists": True, "$ne": None}})
        
        reviewer_state_codes = {}
        for s in distinct_states:
            if s:
                reviewer_state_codes[s.upper()] = s

        # 3. Rewrite reviewer_values.py
        new_timestamp = datetime.datetime.now(ist_timezone).isoformat()
        
        content = f"# Auto-generated by reviewer_mcp.py on {new_timestamp}\n\n"
        content += f"state_crops_reviewer_dataset = {json.dumps(state_crops_reviewer_dataset, indent=4)}\n\n"
        content += f"reviewer_state_codes = {json.dumps(reviewer_state_codes, indent=4)}\n\n"
        content += f"last_updated_metadata = \"{new_timestamp}\"\n"

        current_dir = os.path.dirname(os.path.abspath(__file__))
        values_file = os.path.join(current_dir, 'reviewer_values.py')
        
        with open(values_file, 'w') as f:
            f.write(content)
            
        print("reviewer_values.py updated successfully.")

        # 4. Hot Reload
        importlib.reload(reviewer_values)
        print("reviewer_values module reloaded with new data.")

    except Exception as e:
        print(f"Error updating reviewer data: {e}")
        import traceback
        traceback.print_exc()


# --- MCP Tools ---

@mcp.tool()
async def get_context_from_reviewer_dataset(query: str, state: str = None, crop: str = None):
    """
    Retrieve the most contextually relevant agricultural question-answer pairs 
    from the Reviewer Dataset based on the query, state, and crop.
    
    This wraps the logic defined in reviewer_rag_tool.py.
    """
    await update_reviewer_data()
    
    state_to_pass = None
    
    # 1. Validate State
    if state:
        state_upper = state.upper()
        # reviewer_state_codes maps UPPER_CASE_NAME -> Original Name
        # Check if input matches a known state name (case-insensitive)
        if state_upper in reviewer_values.reviewer_state_codes:
            state_to_pass = reviewer_values.reviewer_state_codes[state_upper]
        
        else:
             # State not found. Return error with available states.
             available_states = sorted(reviewer_values.reviewer_state_codes.values())
             return f"Error: Invalid state name '{state}'. Available states are: {', '.join(available_states)}"

    
    if crop and state_to_pass:
        # Get valid crops for the state
        valid_crops = reviewer_values.state_crops_reviewer_dataset.get(state_to_pass, [])
        
        # Check case-insensitive
        crop_found = False
        for valid_crop in valid_crops:
            if valid_crop.lower() == crop.lower():
                crop = valid_crop # Canonicalize
                crop_found = True
                break
        
        if not crop_found:
            return f"Error: Invalid crop '{crop}' for state '{state_to_pass}'. Available crops are: {', '.join(valid_crops)}"

    # Trigger the underlying tool logic.
    return await reviewer_retriever_tool.ainvoke({"query": query, "crop": crop, "state": state_to_pass})

@mcp.tool()
async def get_available_states_for_reviewer_dataset() -> List[dict]:
    """
    Retrieve the list of available states in the Reviewer Dataset.
    """
    await update_reviewer_data()
    return [{"state": val, "code": key} for key, val in reviewer_values.reviewer_state_codes.items()]

@mcp.tool()
async def get_crops_by_state_for_reviwer_dataset(state: str) -> List[str]:
    """
    Get the list of crops for a specific state in the Reviewer Dataset.
    """
    await update_reviewer_data()
    
    state_full = reviewer_values.reviewer_state_codes.get(state.upper(), state)
    
    crops = reviewer_values.state_crops_reviewer_dataset.get(state_full, [])
    if not crops and state in reviewer_values.state_crops_reviewer_dataset:
        crops = reviewer_values.state_crops_reviewer_dataset[state]

    return crops

if __name__ == "__main__":
    mcp.run(
        transport="streamable-http",
        host="0.0.0.0",
        port=9023,
    )
